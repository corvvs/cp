# 問題

https://atcoder.jp/contests/keyence2019/tasks/keyence2019_d

# メモ

`{A[i]}, {B[j]}`はそれぞれソートしても構わない。

まず、A,Bそれぞれの中で重複がないことを確認する。重複がある場合、答えは`0`.

その後、A,Bを混ぜ合わせてソートする。この時、AとBの重複はまとめる&行と列は区別する。
(操作後の要素は行・列・行かつ列の３種類になる。)

その後、数字が小さいものからみていく:

## 「行」または「列」の場合

- 数字を`x`とする
- その行(列)の要素は`x`以下、かつどこかに`x`がなければならない
- 列(行)のサイズを`L`,すでに使った数字の数を`a`,すでに埋まった列(行)の数を`b`とする
- `C(s,t)`は`s`個の要素から`t`個を選ぶ組み合わせの数とすると、
  - 注意: `s < t`の時、`C(s,t) = 0.`
- 埋め方は`C(x-1-a, L-b-1) * (L-b)!`
  - `x-a-1`個の使える数字から`L-b-1`個を選び、`x`を加えて並び替える

## 「行かつ列」の場合

- 数字を`x`とする
- その行および列の要素は`x`以下、かつどこかに`x`がなければならないが、`x`の位置は確定してしまう
- すでに使った数字の数を`a`,すでに埋まった行と列の数を`b`とすると、
- 埋め方は`C(x-1-a, N+M-b-2) * (N+M-b-2)!`
  - `x-a-1`個の使える数字から`N+M-b-2`個を選んで並び替える
  - 注意: xの位置は確定しているので、並び替えに加えない

上記を繰り返して埋め方を計算し、それを全て掛け合わせたものが答え。\
計算量は`O((N+M)log(NM))`(たぶん; 適当にやると`O(NMlog(NM))`とかになって死ぬ、というか死んだ)
