# 問題

https://atcoder.jp/contests/abc038/tasks/abc038_d

`N`個の箱の縦横のサイズが与えられる。\
ある箱は、自身よりも縦(`h[i]`)・横(`w[i]`)ともに小さいサイズの箱を1つだけ中に入れることができる。\
入れ子にできる最大数を求めよ。

# 制約
- `1 <= N <= 1e5`
- `1 <= w[i] <= 1e5`
- `1 <= h[i] <= 1e5`

# メモ

「しまわれる箱」から「しまう箱」に辺を張ってDAGにする→トポロジカルソート→DP で解けそうだが、辺の数が`O(N^2)`なのでちょっと辛い。

(以下解説と同じ。BITではなくセグメント木だが。)

セグメント木を使ったDPをやる。\
セグメント木の要素数は`max(h[i])`で、演算は`max(,)`とする。

まず箱を縦サイズ(`h`)の降順・横サイズ(`w`)の昇順にソートする。\
先頭の箱から順に以下を繰り返す:

- 箱`i`の縦サイズを`h[i]`とし、`v = find(1,h[i]-1)`とする
- セグメント木を`update(h[i], v+1)`で更新する
  - 縦の降順にソートしてあるので、縦が自分と同じ&横が自分より小さい箱を誤って仕舞うことはない。

最後にセグメント木全体の最大値をとって答えとする。

# コメント

演算がパラメータになっているセグメント木だとTLEしたので、max演算を埋め込んだ。なんだか負けた気がする。
