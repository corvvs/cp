# 問題

https://atcoder.jp/contests/arc050/tasks/arc050_c

整数`A,B,M`が与えられるので、「1を`A`個並べたもの」と「1を`B`個並べたもの」の最小公倍数を`M`で割った余りを求めよ。

# メモ

「1をX個ならべて作られる整数」を`1^X`と書くことにする。

仮に`A > B`とすると、`1^A > 1^B * 10^(A-B)`. 右辺は`1^B`の倍数なので、\
`1^A - 1^B * 10^(A-B) = 1^(A-B)`は、「`1^A`から`1^B`を`10^(A-B)`個まとめて引いたもの」である。\
引き算は最大公約数を保存するので、両者の桁数が(従って両者の値が)一致するまでこれを繰り返すと、\
ユークリッドの互除法と同じ理屈で、桁数は`gcd(A,B)`になる。\
つまり、`gcd(1^A, 1^B) = 1^gcd(A,B)`である。

`lcm(x,y) = x*y/gcd(x,y)`なので、`lcm(1^A,1^B) = 1^A * 1^B / gcd(1^A, 1^B) = 1^A * 1^B / 1^gcd(A,B)`.

以後、`gcd(A,B) = g`とする。

`1^A`の方は、

- `1^1 = 1`
- `1^(2n+1) = 1^2n * 10 + 1`
- `1^2n = 1^n * (10^n + 1)`

と再帰的に計算できる。\
また`1^B / 1^g = Σ[i=0...B/g] 10^(i*g) = h(B/g)`の方は、

- `h(1) = 1`
- `h(2n+1) = h(2n) * 10^g + 1`
- `h(2n) = h(n) * ((10^g)^(n+1) + 1)`

と再帰的に計算できる(両者は「単位」が`10`か`10^g`かの違いしかない)。\
`10^n mod M`はバイナリ法で求めることができ、`(10^g)^n`もまたバイナリ法で求められるので、これで最終的な計算が可能になるはず。
